function processTapResults(tapResults) {
  const features = new Map();
  const runtimeNames = new Set();

  for (const [type, data] of tapResults) {
    if (type !== 'assert') {
      continue;
    }
    const [, runtimeName, featureName, checkName] = data.fullname.match(/^(.+?) > (.+?)(?: > (.+))?$/);

    runtimeNames.add(runtimeName);

    let feature = features.get(featureName);
    if (!feature) {
      feature = {
        runtimes: [],
      };
      features.set(featureName, feature);
    }

    const runtimeIdx = [...runtimeNames].indexOf(runtimeName);
    let runtimeInfo = feature.runtimes[runtimeIdx];
    if (!runtimeInfo) {
      runtimeInfo = feature.runtimes[runtimeIdx] = {
        name: runtimeName,
        total: 0,
        pass: 0,
        skip: false,
      };
    }

    if (data.skip) {
      runtimeInfo.skip = true;
    } else {
      ++runtimeInfo.total;
      if (data.ok) {
        ++runtimeInfo.pass;
      }
    }
  }

  console.log('<!-- Generated by: npm run test:report -->\n');
  console.log('## `import.meta` Status\n');

  const headers = [
    'Feature', ...runtimeNames,
  ];
  console.log(headers.join(' | '));
  console.log(headers.map(() => '---').join(' | '));

  for (const [featureName, feature] of features) {
    console.log([
      featureName,
      ...feature.runtimes.map(runtimeInfo => {
        if (runtimeInfo.skip) {
          return 'n/a';
        }
        if (runtimeInfo.pass === runtimeInfo.total) {
          return 'âœ…';
        }
        return `${runtimeInfo.pass} / ${runtimeInfo.total}`;
      }),
    ].join(' | '));
  }

  console.log('\n');
  console.log(`*Last updated: ${new Date().toISOString()}*`);
}

const chunks = [];
process.stdin.on('data', (chunk) => {
  chunks.push(chunk);
});
process.stdin.on('end', () => {
  const tapResults = JSON.parse(Buffer.concat(chunks).toString());
  processTapResults(tapResults);
});
